# ooder平台技术规范手册（修订版）

## 目录

1. [概述](#1-概述)
2. [核心架构规范](#2-核心架构规范)
   - 2.1 平台核心理念
   - 2.2 应用结构体系
   - 2.3 核心组件层（隶属于主面板层）
   - 2.4 Tabs组件体系
3. [组件化设计规范](#3-组件化设计规范)
   - 3.1 组件总体设计
   - 3.2 组件分类体系
   - 3.3 组件间关系
4. [注解体系规范](#4-注解体系规范)
   - 4.1 视图层注解
   - 4.2 行为和交互注解
   - 4.3 字段注解
   - 4.4 菜单注解
5. [视图设计规范](#5-视图设计规范)
   - 5.1 单一视图规范
   - 5.2 视图嵌套与递归关系
   - 5.3 视图关联关系
   - 5.4 聚合视图规范
6. [具体视图类型规范](#6-具体视图类型规范)
   - 6.1 表单规范
   - 6.2 TreeGrid表格和Gallery规范
   - 6.3 Tree规范
   - 6.4 Tabs和Group规范
7. [Page规范](#7-page规范)
   - 7.1 Page核心概念
   - 7.2 Page结构规范
   - 7.3 Page生命周期管理
8. [通讯组件规范](#8-通讯组件规范)
   - 8.1 APIEvent通讯组件
   - 8.2 MQTT通讯组件
   - 8.3 按钮事件通讯组件
   - 8.4 自定义动作通讯组件
   - 8.5 Page上下文环境(PageCtx)
9. [服务规范](#9-服务规范)
   - 9.1 通用服务注解规范
   - 9.2 BAR服务规范
   - 9.3 模块跳转服务规范
10. [参数规范](#10-参数规范)
    - 10.1 参数设计原则
    - 10.2 参数使用场景
    - 10.3 参数传递规范
11. [最佳实践与注意事项](#11-最佳实践与注意事项)

---

## 1. 概述

ooder平台是一个基于注解驱动的前端框架，通过丰富的注解体系实现前后端的强映射关系。平台采用组件化设计理念，通过"干-支-叶"的结构化设计模式，实现了从基础组件到复杂应用场景的完整覆盖。

有关ooder平台的全栈架构设计理念，请参考[ooder平台全栈架构概述](ooder平台全栈架构概述.md)。

有关ooder平台核心概念的统一解释，请参考[ooder平台核心概念统一解释](ooder平台核心概念统一解释.md)。

## 2. 核心架构规范

### 2.1 平台核心理念

1. **注解驱动架构**：通过声明式注解配置实现视图结构和行为定义，将配置与业务逻辑分离，提高代码的可维护性和可读性。
2. **组件化设计**：将复杂功能拆分为可复用的组件模块，通过组合不同组件实现复杂业务场景。
3. **Web可访问性**：所有服务均基于Spring MVC实现Web可访问性，确保服务可以通过HTTP协议进行访问。
4. **前后端分离**：通过注解实现前后端的强类型映射，确保数据传输的一致性和完整性。

### 2.2 应用结构体系

ooder平台的应用结构体系遵循分层设计模式，从宏观到微观分为Page页面容器层、导航层和主面板层：

#### 2.2.1 Page页面容器层
Page页面容器层是应用的最外层结构，定义了整个页面的基本布局和全局配置：

1. **页面容器**：提供页面的根容器，包含全局样式、主题和基础配置
2. **通讯组件**：提供页面级别的通讯机制，如APIEvent、MQTT等
3. **全局服务**：提供页面级别的服务，如数据绑定器、计时器等

#### 2.2.2 导航层
导航层负责应用内的页面跳转和模块导航，包含全局布局：

1. **全局布局**：定义应用的整体布局结构，如顶部导航、侧边栏、主内容区等
2. **主导航**：提供应用主要功能模块的导航入口
3. **侧边导航**：提供当前模块内子功能的导航
4. **面包屑导航**：显示用户当前位置和路径
5. **标签页导航**：管理打开的页面标签

#### 2.2.3 主面板层
主面板层是应用的核心内容展示区域，包含具体的功能页面和行为交互：

1. **页面容器**：承载具体功能页面的容器
2. **内容区域**：展示具体业务内容的区域
3. **工具栏**：提供当前页面操作的工具按钮
4. **状态栏**：显示当前页面的状态信息
5. **行为交互**：包括弹出菜单、辅助输入等交互元素

### 2.3 核心组件层（隶属于主面板层）

核心组件层是主面板层内部的核心组件体系，包含三个顶级分支：TABS、GROUP、BLOCK：

#### 2.3.1 TABS组件
TABS是复合容器组件，用于组织和管理多个子视图：

1. **容器特性**：作为容器类组件，可以包含其他容器类组件（PANEL、BLOCK等）
2. **组合规则**：只允许容器类组件加入
3. **子类组件**：包括ButtonViews、FoldingTabs、Stacks等

#### 2.3.2 GROUP组件
GROUP是分组容器组件，用于将相关元素进行归类：

1. **容器特性**：作为容器类组件，可以包含其他容器类组件（PANEL、BLOCK等）
2. **组合规则**：只允许容器类组件加入
3. **应用场景**：用于逻辑分组和布局组织

#### 2.3.3 BLOCK组件
BLOCK是基础容器组件，提供灵活的布局能力：

1. **容器特性**：作为单一容器，允许添加简单子组件
2. **组合规则**：如果加入其他容器组件则需要使用内嵌容器组件作为关联
3. **应用场景**：适用于自定义布局和组件组织

### 2.4 Tabs组件体系

ooder平台的核心组件体系遵循"干-支-叶"结构化设计模式，Tabs组件体系是其中的重要组成部分：

#### 2.4.1 干：TabsAnnotation核心注解
TabsAnnotation是Tabs组件体系的核心，定义了Tabs组件的基本行为和属性：

**核心属性：**
- barLocation：控制标签栏的显示位置（BarLocationType.top/none）
- sideBarStatus：控制侧边栏的展开状态（SideBarStatusType.expand/fold）
- iniFold：控制Tabs初始化时是否折叠（true/false）
- bindTypes：可绑定的组件类型（ComponentType.BUTTONVIEWS/TABS/STACKS/FOLDINGTABS）

**核心功能：**
- 传统Tabs模式：显示标签栏，用户可以切换不同标签页
- Card模式：隐藏标签栏，仅显示内容区域，类似于独立的卡片组件
- 多步骤CARD模式：将复杂表单分解为多个独立的CARD页面

#### 2.4.2 支：Tabs组件体系子类
1. **ButtonViews（按钮导航）**
   - ComponentType.BUTTONVIEWS继承自ComponentType.TABS
   - 特有属性noFoldBar控制是否显示折叠按钮
   - 在移动端有专门的MButtonViews变体

2. **FoldingTabs（折叠Tabs）**
   - ComponentType.FOLDINGTABS继承自ComponentType.TABS
   - 支持内容区域的折叠和展开
   - 适用于内容较多的导航场景

3. **Stacks（堆栈容器）**
   - ComponentType.STACKS继承自ComponentType.TABS
   - 以堆栈形式展示内容
   - 支持层叠显示多个内容区域

#### 2.4.3 叶：具体应用场景实现
1. **Card模式应用场景**
   - 独立信息展示：当只需要展示单一内容而不需要标签切换时
   - 聚合视图中的独立卡片：作为聚合视图中的信息块展示

2. **多步骤CARD模式应用场景**
   - 复杂信息录入：员工入职信息录入、项目申报表、客户资料录入等
   - 多阶段业务流程：申请流程、订单处理、调查问卷等
   - 自助建模中的自适应调整：根据字段数量自动分组并提供暂存和提交功能

## 3. 组件化设计规范

### 3.1 组件总体设计

ooder平台的组件化设计遵循统一的总体设计理念，将所有功能单元抽象为组件，通过标准化的接口和注解实现组件的高复用性。组件设计遵循以下原则：

1. **单一职责原则**：每个组件应有明确的职责和用途
2. **可复用性原则**：设计通用组件，提高代码复用率
3. **可维护性原则**：保持代码结构清晰，易于理解和修改
4. **可扩展性原则**：提供扩展机制，支持自定义组件的开发和集成

### 3.2 组件分类体系

根据功能和用途，ooder平台的组件分为以下几类：

1. **视图组件**：负责用户界面的展示和交互
2. **服务组件**：负责业务逻辑处理和服务调用
3. **通讯组件**：负责前后端数据交互和消息传递
4. **字段组件**：负责具体的数据展示和输入

### 3.3 组件间关系

组件间存在多种关系类型，确保组件能够协同工作：

1. **包含关系**：一个组件包含其他组件作为子组件
2. **依赖关系**：一个组件依赖于其他组件的功能
3. **继承关系**：组件间存在继承和派生关系
4. **关联关系**：组件间通过特定机制进行数据传递和状态同步

## 4. 注解体系规范

### 4.1 视图层注解（外观配置）
- **@CustomAnnotation**：底层通用外观配置
- **@FormViewAnnotation**：表单视图定义
- **@TreeGridViewAnnotation**：网格视图定义
- **@FormAnnotation**：表单配置注解
- **@PanelFormAnnotation**：面板表单注解
- **@TreeGridAnnotation**：网格配置注解
- **@PanelAnnotation**：面板容器定义
- **@DialogAnnotation**：对话框容器定义

### 4.2 行为和交互注解（服务层）
- **@APIEventAnnotation**：核心基础行为配置，定义事件交互行为
- **@ModuleAnnotation**：模块定义注解，用于定义应用模块

### 4.3 字段注解
- **@InputAnnotation**：输入框配置
- **@DatePickerAnnotation**：日期选择器配置
- **@ComboBoxAnnotation**：下拉框配置
- **@ButtonAnnotation**：按钮配置
- **@CustomListAnnotation**：自定义列表配置，用于增强枚举字段的数据能力
- **@ComboAnnotation**：基础复合输入注解，更多详情请参考[ooder平台Combo组件专题手册](ooder平台Combo组件专题手册.md)
- **@ComboBoxAnnotation**：下拉框注解
- **@ComboInputAnnotation**：输入框注解
- **@ComboNumberAnnotation**：数字输入注解
- **@ComboPopAnnotation**：弹出框注解

### 4.4 菜单注解
- **@ToolBarMenu**：工具栏配置
- **@BottomBarMenu**：底部栏配置
- **CustomFormMenu**：预定义菜单项
- **TreeGridMenu**：网格菜单项

## 5. 视图设计规范

### 5.1 单一视图规范

#### 5.1.1 视图类型规范
1. **表单视图**：用于数据录入和展示，使用@FormAnnotation或@FormViewAnnotation注解定义。
2. **列表视图**：用于数据展示和操作，使用@TreeGridAnnotation或@TreeGridViewAnnotation注解定义。
3. **门户视图**：用于整合多个信息模块，使用@FormAnnotation注解定义。

#### 5.1.2 视图数据结构规范
1. **视图对象的双重角色**：
   - 数据传输对象(DTO)：视图对象作为数据载体，用于前后端数据传输
   - 视图配置载体：通过注解定义视图的外观、行为和交互

2. **字段注解规范**：
   - 输入控件注解：@InputAnnotation、@DatePickerAnnotation、@ComboBoxAnnotation、@ButtonAnnotation
   - 列表增强注解：@CustomListAnnotation

#### 5.1.3 视图结构规范
1. **视图类结构**：
   - 类注解定义视图类型和属性
   - 字段定义及相应注解
   - 必要的getter/setter方法
   - 可选的业务逻辑方法

2. **注解使用规范**：
   - @CustomAnnotation用于定义字段的外观属性（caption、index、imageClass等）
   - 视图类型注解定义视图的整体行为
   - 菜单注解定义工具栏和底部栏配置

### 5.2 视图嵌套与递归关系

#### 5.2.1 视图允许嵌套和引用
1. **视图嵌套**：视图可以包含其他视图作为子组件，实现复杂界面的构建。
2. **视图引用**：支持视图间的引用关系，实现模块化设计。

#### 5.2.2 递归嵌套节点设计
1. **递归引用特性**：当主干节点出现递归引用时，bindClass（视图聚合服务类，其中必须包含视图入口方法）作为核心节点属性。
2. **枚举方式实现递归**：对于新出现的节点递归嵌套，通常将嵌套的节点采用item枚举的方式来实现有效的结构。

### 5.3 视图关联关系

#### 5.3.1 视图父子关系
1. **定义**：父子关系指一个视图作为另一个视图的子组件存在，父视图拥有对子视图的控制权。
2. **特征**：
   - 父视图决定子视图的显示和隐藏
   - 子视图的生命周期依赖于父视图
   - 数据传递通常从父视图流向子视图

#### 5.3.2 视图顺序关系
1. **定义**：顺序关系指多个视图按照一定的顺序依次执行或显示，前一个视图的结果影响后一个视图的行为。
2. **特征**：
   - 视图间存在明确的执行顺序
   - 数据在视图间顺序传递
   - 通常用于向导式操作流程

#### 5.3.3 视图并行关系
1. **定义**：并行关系指多个视图可以同时存在和操作，彼此相对独立但又存在一定的关联。
2. **特征**：
   - 多个视图可同时显示
   - 视图间相对独立运行
   - 可能存在数据共享或状态同步需求

## 6. 具体视图类型规范

### 6.1 表单规范

#### 6.1.1 表单类型
ooder平台支持多种表单类型：
- **@FormAnnotation**：标准表单，用于常规数据录入和展示
- **@PanelFormAnnotation**：面板表单，用于在面板容器中展示的表单
- **@SVGPaperFormAnnotation**：SVG画布表单，用于矢量图绘制和展示
- **@FormViewAnnotation**：表单视图，通常用于模块入口

#### 6.1.2 表单类型注解

##### @FormAnnotation
@FormAnnotation用于定义表单配置，是最常用的表单注解。

**核心属性：**
- borderType：边框类型
- col：列数
- row：行数
- customService：关联的自定义服务类
- mode：表单模式（读写模式）

##### @PanelFormAnnotation
@PanelFormAnnotation用于定义面板表单，适用于在面板容器中展示的表单，支持多重嵌套。

**核心属性：**
- dock：停靠位置
- caption：标题
- borderType：边框类型
- customService：关联的自定义服务类
- toggle：是否可切换
- noFrame：是否无边框

##### @SVGPaperFormAnnotation
@SVGPaperFormAnnotation用于定义SVG画布表单，适用于矢量图绘制和展示场景。

**核心属性：**
- selectable：是否可选择
- iframeAutoLoad：iframe自动加载URL
- html：HTML内容
- width：宽度
- height：高度
- overflow：溢出处理方式
- scaleChildren：是否缩放子元素
- graphicZIndex：图形层级
- customMenu：自定义菜单
- event：事件处理
- bottombarMenu：底部栏菜单
- customService：关联的自定义服务类

##### @FormViewAnnotation
@FormViewAnnotation用于定义表单视图，通常用于模块入口。

#### 6.1.3 表单字段注解

##### 基础输入控件
- @InputAnnotation：输入框配置
- @DatePickerAnnotation：日期选择器配置
- @ComboBoxAnnotation：下拉选择框
- @ButtonAnnotation：按钮配置
- @ComboAnnotation：复合输入框，更多详情请参考[ooder平台Combo组件专题手册](ooder平台Combo组件专题手册.md)
- @ComboBoxAnnotation：下拉输入框
- @ComboInputAnnotation：输入框
- @ComboNumberAnnotation：数字输入框
- @ComboPopAnnotation：弹出框

##### 列表增强注解
- @CustomListAnnotation：用于增强枚举字段的数据能力

#### 6.1.4 表单布局规范

##### 布局属性
- **col**：定义表单列数，影响字段的水平排列
- **row**：定义表单行数，影响表单整体高度
- **borderType**：定义表单边框样式
- **mode**：定义表单模式（读写模式）

##### 字段排列
- 使用@index属性控制字段的显示顺序
- 合理分配字段到不同列中
- 考虑字段的重要性和逻辑分组

##### 样式配置
- 使用@CustomAnnotation定义字段标题、图标等外观属性
- 合理设置边框和间距
- 考虑响应式设计需求

#### 6.1.5 表单数据处理

##### 数据验证
- 在服务端进行数据验证
- 合理设置字段的必填性和长度限制
- 提供友好的错误提示信息

##### 数据传输
- 使用@RequestBody注解处理表单提交数据
- 确保前后端数据结构一致性
- 合理设计数据传输对象

##### 数据持久化
- 通过customService关联数据处理服务
- 实现数据的增删改查操作
- 处理事务和异常情况

#### 6.1.6 表单服务规范

##### 服务注解
表单相关服务必须使用以下注解：
- @Aggregation：声明服务类型
- @RestController：声明REST控制器
- @Service：声明服务组件
- @RequestMapping：声明请求映射

##### 服务方法
- 使用@PostMapping/@GetMapping等Spring Web注解
- 方法命名清晰表达功能语义
- 包含完整的异常处理逻辑

##### 返回数据
- 统一使用ResultModel或ListResultModel标准返回类型
- 遵循fastjson序列化规范
- 在特定视图操作环境下，应优先使用视图对象作为返回值的泛型类型

#### 6.1.7 表单BAR组件

##### 工具栏配置
使用@ToolBarMenu配置表单工具栏：

##### 底部栏配置
使用@BottomBarMenu配置表单底部栏：

##### BAR服务实现
BAR服务类必须遵循以下规范：
- 使用@Aggregation(type = AggregationType.MENU)注解
- 实现具体的业务逻辑方法
- 使用@APIEventAnnotation和@CustomAnnotation注解

#### 6.1.8 表单最佳实践

##### 设计原则
1. **用户友好**：界面简洁明了，操作流程清晰
2. **数据一致**：确保前后端数据传输的一致性
3. **性能优化**：合理使用懒加载和缓存机制
4. **可维护性**：代码结构清晰，便于后续维护

##### 实现规范
1. **注解使用**：正确使用表单相关注解
2. **字段设计**：合理设计字段类型和验证规则
3. **服务分离**：视图与服务分离，职责清晰
4. **异常处理**：完善的异常处理机制

##### 注意事项
1. 避免在表单中混合使用不同类型的注解
2. 合理配置表单布局属性
3. 正确使用@Uid注解标识行主键
4. 所有BAR服务逻辑应在独立的服务类中实现

### 6.2 TreeGrid表格和Gallery规范

#### 6.2.1 TreeGrid注解类型

##### @TreeGridAnnotation
@TreeGridAnnotation用于定义标准的网格列表视图：

**核心属性：**
- customService：关联的自定义服务类
- showHeader：是否显示表头
- colSortable：列是否可排序
- altRowsBg：是否交替行背景色
- customMenu：自定义菜单项
- bottombarMenu：底部栏菜单项

##### @TreeGridViewAnnotation
@TreeGridViewAnnotation用于定义网格视图，通常用于模块入口。

##### @MTreeGridAnnotation
@MTreeGridAnnotation用于定义移动端的网格列表视图。

#### 6.2.2 TreeGrid字段注解

TreeGrid视图中的字段通常使用标准的输入注解：

#### 6.2.3 TreeGrid菜单和事件

##### TreeGridMenu预定义菜单项

##### CustomTreeGridEvent预定义事件

#### 6.2.4 TreeGrid数据结构

##### ListResultModel
用于普通列表数据：

##### TreeListResultModel
用于树形列表数据：

#### 6.2.5 Gallery规范

##### Gallery注解类型

###### @GalleryAnnotation
@GalleryAnnotation用于定义画廊视图：

**核心属性：**
- customService：关联的自定义服务类
- showHeader：是否显示表头
- colResizable：列是否可调整大小
- customMenu：自定义菜单项

##### Gallery字段注解

Gallery视图中的字段通常使用图片相关的注解：

##### Gallery布局规范

###### 布局属性
- **列数控制**：通过CSS控制每行显示的图片数量
- **响应式设计**：根据屏幕尺寸自动调整布局
- **缩略图处理**：合理设置缩略图大小和质量

###### 样式配置
- 使用@CustomAnnotation定义字段标题、图标等外观属性
- 合理设置边框和间距
- 考虑图片加载和显示效果

#### 6.2.6 数据处理规范

##### 数据验证
- 在服务端进行数据验证
- 合理设置字段的必填性和长度限制
- 提供友好的错误提示信息

##### 数据传输
- 使用@RequestBody注解处理数据提交
- 确保前后端数据结构一致性
- 合理设计数据传输对象

##### 数据分页
- 实现分页查询功能
- 合理设置每页显示记录数
- 提供页码导航功能

#### 6.2.7 TreeGrid和Gallery服务规范

##### 服务注解
TreeGrid和Gallery相关服务必须使用以下注解：
- @Aggregation：声明服务类型
- @RestController：声明REST控制器
- @Service：声明服务组件
- @RequestMapping：声明请求映射

##### 服务方法
- 使用@PostMapping/@GetMapping等Spring Web注解
- 方法命名清晰表达功能语义
- 包含完整的异常处理逻辑

##### 返回数据
- 统一使用ListResultModel或TreeListResultModel标准返回类型
- 遵循fastjson序列化规范
- 在特定视图操作环境下，应优先使用视图对象作为返回值的泛型类型

#### 6.2.8 BAR组件规范

##### 工具栏配置
使用@ToolBarMenu配置TreeGrid/Gallery工具栏：

##### 底部栏配置
使用@BottomBarMenu配置TreeGrid/Gallery底部栏：

##### BAR服务实现
BAR服务类必须遵循以下规范：
- 使用@Aggregation(type = AggregationType.MENU)注解
- 实现具体的业务逻辑方法
- 使用@APIEventAnnotation和@CustomAnnotation注解

#### 6.2.9 TreeGrid和Gallery最佳实践

##### TreeGrid设计原则
1. **数据清晰**：表格数据结构清晰，易于理解
2. **操作便捷**：提供常用的操作功能，如排序、筛选、分页
3. **性能优化**：合理使用分页和懒加载机制
4. **响应式设计**：适配不同屏幕尺寸

##### Gallery设计原则
1. **视觉美观**：图片展示效果良好，布局合理
2. **加载优化**：使用缩略图和懒加载提高性能
3. **交互友好**：提供图片预览和操作功能
4. **响应式设计**：适配不同屏幕尺寸

##### 实现规范
1. **注解使用**：正确使用TreeGrid/Gallery相关注解
2. **字段设计**：合理设计字段类型和显示方式
3. **服务分离**：视图与服务分离，职责清晰
4. **异常处理**：完善的异常处理机制

##### 注意事项
1. 避免在TreeGrid/Gallery中混合使用不兼容的注解
2. 合理配置TreeGrid/Gallery布局属性
3. 正确使用@Uid注解标识行主键
4. 所有BAR服务逻辑应在独立的服务类中实现
5. 确保列表视图的单一性，不得添加表单视图注解

### 6.3 Tree规范

#### 6.3.1 Tree组件核心特性

##### 递归数据结构支持
- 支持无限层级的节点嵌套
- 每个节点可包含子节点列表
- 支持懒加载子节点数据

##### 节点操作
- 节点展开/折叠
- 节点选择
- 节点编辑
- 节点拖拽排序

##### 视觉呈现
- 树形缩进展示
- 连接线显示父子关系
- 节点图标自定义
- 高亮选中节点

#### 6.3.2 Tree注解体系

##### @TreeAnnotation
Tree组件的核心注解，用于定义Tree视图的基本属性。

##### @TreeNodeAnnotation
用于标记Tree节点字段，定义节点的显示属性。

#### 6.3.3 Tree字段注解

##### @TreeNodeField
用于定义节点字段的显示和行为特性。

#### 6.3.4 Tree菜单和事件处理

##### 标准菜单项
- 添加节点
- 删除节点
- 编辑节点
- 刷新树

##### 事件处理
- 节点点击事件
- 节点展开事件
- 节点拖拽事件
- 节点选择变更事件

#### 6.3.5 Tree服务规范

##### 数据加载服务

##### 节点操作服务

#### 6.3.6 Tree递归关系实现

##### 递归数据模型

##### 递归解析机制
- 服务端提供扁平数据列表
- 前端自动构建树形结构
- 支持按需加载子节点

#### 6.3.7 Tree最佳实践

##### 性能优化
- 大数据量时使用虚拟滚动
- 合理设置节点缓存策略
- 懒加载子节点数据

##### 用户体验
- 提供搜索过滤功能
- 支持键盘导航
- 明确的节点状态反馈

##### 数据一致性
- 确保父子节点数据同步
- 提供撤销操作支持
- 验证节点操作的合法性

### 6.4 Tabs和Group规范

#### 6.4.1 Tabs组件规范

##### 核心概念
Tabs组件允许用户在不同的视图或内容面板之间切换，通过标签页的形式组织相关内容，减少界面的复杂性。

##### @TabsAnnotation注解
Tabs组件的核心注解，用于定义Tabs视图的基本属性。

##### Tabs枚举实现
Tabs通过枚举类型定义各个标签页的内容和属性。

#### 6.4.2 Group组件规范

##### 核心概念
Group组件用于将相关的表单元素或控件组织在一起，通过分组框的形式提高界面的可读性和逻辑性。

##### @GroupAnnotation注解
Group组件的核心注解，用于定义Group视图的基本属性。

##### Group字段组织
Group内部可以包含各种表单字段和子组件。

#### 6.4.3 Tabs与Group的组合使用

##### 层级嵌套
Tabs和Group可以相互嵌套，形成复杂的界面结构。

##### 数据联动
Tabs切换时可以触发Group内容的更新，实现数据联动。

#### 6.4.4 Tabs子类型规范

##### ButtonViews
ButtonViews是Tabs的一种特殊形式，通过按钮组的方式切换内容。

##### FoldingTabs
FoldingTabs支持折叠功能的Tabs组件，节省界面空间。

##### Stacks
Stacks是一种堆叠式Tabs，支持内容的层叠展示。

#### 6.4.5 服务规范

##### Tabs服务

##### Group服务

#### 6.4.6 Tabs和Group最佳实践

##### 界面设计原则
- Tabs适用于平级内容的切换
- Group适用于相关元素的归类
- 避免过深的嵌套层级
- 保持标签页标题简洁明了

##### 性能优化
- 延迟加载非活跃标签页内容
- 合理使用缓存机制
- 优化Group内容渲染性能

##### 用户体验
- 提供清晰的视觉层次
- 保持操作一致性
- 支持键盘快捷键导航
- 明确标识当前激活状态

## 7. Page规范

### 7.1 Page核心概念

#### 定义
Page是视图组件的容器和组织者，具有以下特征：
- 最少由一个视图组成
- 是面向用户的最小单位
- 包含当前环境变量（隐含）
- 集成数据通讯组件（ajax/api）
- 集成消息组件
- 集成样式主体组件等公共性支撑功能

#### Page与视图的关系
- Page是视图的容器，视图是Page的组成部分
- 一个Page可以包含多个视图组件
- Page负责协调视图组件间的数据传递和状态同步

### 7.2 Page结构规范

#### Page基本结构
Page由以下核心组件构成：
1. **视图容器**：包含一个或多个视图组件
2. **环境变量**：当前用户的上下文信息、权限信息等
3. **数据通讯层**：负责与后端服务的数据交互
4. **消息处理层**：处理系统消息和用户通知
5. **样式主题层**：定义页面的整体外观和交互风格
6. **事件处理层**：处理用户交互事件和组件事件绑定
7. **参数上下文**：存储页面运行时参数的上下文环境

#### Page动态生成机制
Page对象通过Web容器拦截机制动态生成，当用户访问具有Web可访问性的视图入口时，系统会自动将其包装为Page对象：

Page的动态生成过程遵循以下规则：
1. 所有视图入口都必须具有Web可访问性
2. Web容器拦截用户请求并识别视图入口
3. 系统自动将视图对象包装为Page对象
4. Page对象集成环境变量、数据通讯组件、消息组件等公共功能
5. 系统将视图所需的数据接口转换为Ajax定义（APIEventAnnotation）
6. 将组件的Event定义实例化并与视图/元素进行绑定
7. 根据视图入口方法的参数，将参数汇聚到PageCtx页面当前环境中
8. 将视图所需的服务端交互从视图绑定的服务类中获取可Web访问的method方法，并将其编译为页面的Ajax通讯组件

#### Page注解体系
虽然Page对象是动态生成的，但相关的视图组件和服务仍然需要使用注解来定义其行为和属性：

### 7.3 Page与视图组件的关系

#### 包含关系
Page作为容器包含各种视图组件。虽然Page对象是动态生成的，但在Page内部仍然可以包含多个视图组件：

#### 数据流关系
Page负责协调各视图组件间的数据流：

### 7.4 Page动态构建过程

#### 视图数据接口转换
在Page动态构建过程中，系统会将各个视图所需的数据接口转换为Ajax定义：

#### 事件绑定机制
Page在构建时会将组件的Event定义实例化并与视图/元素进行绑定：

#### 参数汇聚到Page上下文
Page会根据视图入口方法的参数，将参数汇聚到PageCtx页面当前环境中：

#### API通讯组件编译
Page会将视图所需的服务端交互从视图绑定的服务类中获取可Web访问的method方法，并将其编译为页面的Ajax通讯组件：

### 7.5 Page生命周期管理

#### 初始化阶段
1. 加载Page配置信息
2. 初始化环境变量
3. 创建视图组件实例
4. 建立组件间关系

#### 运行阶段
1. 处理用户交互事件
2. 协调视图组件数据更新
3. 管理组件状态变化
4. 处理消息通知

#### 销毁阶段
1. 释放视图组件资源
2. 清理环境变量
3. 断开数据连接
4. 保存页面状态（如需要）

### 7.6 Page服务规范

#### PageDataService接口

#### Page事件处理

### 7.7 Page与BAR服务的关系

#### BAR服务在Page中的作用
BAR服务作为Page的一部分，提供导航和菜单功能。虽然Page对象是动态生成的，但BAR服务仍然可以与Page集成：

#### BAR与Page的集成

### 7.8 Page最佳实践

#### 设计原则
1. **单一职责原则**：每个Page应有明确的业务职责
2. **高内聚低耦合**：Page内部组件高内聚，Page间低耦合
3. **可复用性**：设计可复用的Page模板和组件

#### 实现规范
1. **注解使用规范**：正确使用Page相关注解
2. **数据一致性**：确保Page内各组件数据的一致性
3. **性能优化**：合理使用懒加载和缓存机制
4. **API设计规范**：确保所有服务方法都具有Web可访问性并声明@Aggregation注解

#### 用户体验
1. **响应式设计**：适配不同设备和屏幕尺寸
2. **状态反馈**：提供清晰的操作状态反馈
3. **导航便利**：提供便捷的页面导航和返回机制
4. **事件绑定清晰**：明确标注组件与服务方法的绑定关系

## 8. 通讯组件规范

### 8.1 APIEvent通讯组件

#### 概述
APIEvent是ooder平台中最常用的通讯组件，用于定义前后端交互的事件处理行为。通过@APIEventAnnotation注解，可以将服务方法与前端组件事件进行绑定。

#### 核心注解

#### APIEvent事件类型

#### 使用示例

### 8.2 MQTT通讯组件

#### 概述
MQTT是ooder平台支持的轻量级消息传输协议，适用于物联网设备通信和实时消息推送场景。

#### 核心注解

#### MQTT事件类型

#### 使用示例

### 8.3 按钮事件通讯组件

#### 概述
按钮事件通讯组件用于处理用户界面中按钮的点击事件和其他交互行为。

#### 核心注解

#### 按钮事件类型

#### 使用示例

### 8.4 自定义动作通讯组件

#### 概述
自定义动作通讯组件提供了丰富的动作类型，用于定义组件在特定事件发生时应执行的操作。

#### 核心注解

#### 动作类型枚举

#### 消息动作类型

#### 页面动作类型

### 8.5 Page上下文环境（PageCtx）

#### 概述
Page上下文环境（PageCtx）是ooder平台中一个重要的概念，它作为统一的环境变量管理机制，在Page动态构建过程中发挥关键作用。PageCtx包含页面运行所需的所有上下文信息，包括视图中的环境变量、用户会话信息、页面参数等。

#### 环境变量汇聚机制
在Page动态构建过程中，系统会根据视图入口方法的参数，将参数汇聚到PageCtx页面上下文中：

#### 视图环境变量收集
在视图中，通常会使用字段上添加@Pid、@Uid等注解显式地将其加入到整个页面的当前环境中：

在Page初始化（编译）的过程中，系统会将所有视图中的环境变量都搜集到PageCtx中。

@Pid和@Uid注解的定义：

#### APIEvent中的上下文参数传递

##### 上行参数配置
在APIEvent配置上行参数时，通常会默认将PageCtx加入进来：

##### 下行参数配置
在下行参数中，也允许通过向ResultModel的ctx属性赋值来修改当前页面：

ResultModel中与PageCtx相关的方法：

#### PageCtx使用最佳实践

##### 环境变量命名规范
1. 使用清晰、具有业务含义的命名
2. 避免使用保留关键字
3. 保持命名风格一致性

##### 数据传递规范
1. 上行参数中合理选择RequestPathEnum枚举值
2. 下行参数中通过ctx传递需要更新的上下文信息
3. 避免在ctx中传递大量不必要的数据

##### 安全性考虑
1. 对敏感信息进行适当处理
2. 验证ctx中传递的数据合法性
3. 避免在客户端暴露敏感的上下文信息

##### 性能优化
1. 只传递必要的上下文变量
2. 避免在ctx中存储大对象
3. 合理使用addCtx方法进行增量更新

### 8.6 通讯组件最佳实践

#### 设计原则
1. **单一职责原则**：每个通讯组件应有明确的职责和用途
2. **可配置性**：通过注解参数提供灵活的配置选项
3. **可扩展性**：支持自定义事件和动作扩展
4. **安全性**：确保通讯过程中的数据安全

#### 实现规范
1. **注解使用规范**：正确使用各类通讯注解
2. **Web可访问性**：所有服务必须实现Web可访问性
3. **数据一致性**：确保前后端数据传输的一致性
4. **错误处理**：提供完善的错误处理机制

#### 性能优化
1. **异步处理**：合理使用异步查询提高响应速度
2. **连接复用**：对于长连接通讯组件，实现连接复用
3. **数据压缩**：在网络传输中使用数据压缩技术
4. **缓存机制**：合理使用缓存减少重复请求

#### 安全规范
1. **认证授权**：实现完善的认证授权机制
2. **数据加密**：敏感数据传输时使用加密技术
3. **访问控制**：严格控制组件的访问权限
4. **日志记录**：记录关键通讯操作日志

### 8.7 通讯组件集成

#### 与Page的集成
通讯组件在Page动态构建过程中发挥重要作用：
1. APIEvent组件将服务方法编译为页面的Ajax通讯组件
2. MQTT组件实现页面与消息服务器的实时通信
3. 数据路径枚举确保参数在PageCtx中的正确传递

#### 与视图组件的集成
1. **Form视图**：通过APIEvent实现表单数据提交和验证
2. **TreeGrid视图**：通过APIEvent实现数据加载和操作
3. **Tree视图**：通过MQTT实现节点状态实时更新
4. **Tabs视图**：通过APIEvent实现标签页内容动态加载

#### 与BAR服务的集成
1. BAR服务中的菜单项通过APIEvent与后端服务绑定
2. BAR服务中的按钮动作通过CustomAction与通讯组件关联
3. 实现BAR操作的异步处理和状态反馈

## 9. 服务规范

### 9.1 通用服务注解规范

#### Web可访问性规范
所有通用服务必须采用Spring MVC注解：

必须使用@Aggregation注解声明服务类型：

#### 服务类型定义
1. **BAR服务**：处理工具栏和底部栏操作，声明为AggregationType.MENU
2. **通用视图服务**：处理视图业务逻辑，声明为AggregationType.API
3. **服务入口服务**：模块主入口点，应作为普通Web服务实现
4. **导航服务**：处理视图间跳转，声明为MENU类型
5. **模块跳转服务**：应使用@ModuleAnnotation进行配置

#### 注解使用规范
- **@APIEventAnnotation**：定义事件处理行为
- **@CustomAnnotation**：定义服务显示信息（如标题、图标、索引等）
- **@ModuleAnnotation**：用于模块跳转配置
- **@Aggregation**：必须用于声明服务类型和用户空间

#### 返回数据规范
- 统一使用ResultModel或ListResultModel标准返回类型
- 遵循fastjson序列化规范
- 在特定视图操作环境下，应优先使用视图对象作为返回值的泛型类型

#### 方法规范
- 使用@PostMapping/@GetMapping等Spring Web注解
- 方法命名清晰表达功能语义
- 包含完整的异常处理逻辑

### 9.2 BAR服务规范

#### BAR服务分类
1. **具有Web访问能力的BAR服务**：提供具体的业务逻辑方法并暴露为Web服务
2. **仅提供菜单配置的BAR服务**：仅提供菜单配置方法

#### BAR服务规范
1. **注解要求**：
   - 必须使用@Aggregation注解声明服务类型为AggregationType.MENU
   * 必须指定userSpace为UserSpace.SYS

2. **功能规范**：
   - 可实现具体业务逻辑并暴露为Web服务
   - 也可仅用于提供菜单/工具栏配置
   - 两类服务可根据实际场景共存，但应保持职责清晰

3. **命名规范**：
   - 类名应以BarService结尾
   - 方法名应清晰表达其功能

#### BAR组件共性规范
在ooder平台中，BAR组件包括Tabs中的bar与独立的bar（menubar、toolbar、bottombar、statusbar）等，它们具有以下共性：

1. **统一的注解体系**：
   - 所有BAR组件均使用统一的@Aggregation(type = AggregationType.MENU)注解声明
   - 均遵循相同的Web可访问性规范，采用Spring MVC注解体系
   - 均可使用@CustomAnnotation定义显示信息（标题、图标、索引等）

2. **一致的行为配置**：
   - 均支持@APIEventAnnotation定义事件交互行为
   - 均支持事件绑定、参数配置、回调处理等核心功能
   - 均可与视图对象进行数据交互

3. **统一的服务规范**：
   - 均需声明userSpace为UserSpace.SYS
   - 均需遵循ooder服务规范，确保Web可访问性
   - 均使用统一的ResultModel或ListResultModel返回类型

#### BAR组件差异性规范
1. **Tabs中的bar**：
   - 作为Tabs组件的一部分，与Tabs内容区域紧密关联
   - 通过barLocation属性控制显示位置
   - 支持与Tabs内容区域的联动交互

2. **独立的bar组件**：
   - **MenuBar**：通常位于页面顶部，提供全局导航功能
   - **ToolBar**：通常位于页面顶部或视图区域上方，提供工具操作功能
   - **BottomBar**：通常位于页面底部，提供辅助操作功能
   - **StatusBar**：通常位于页面底部，提供状态信息展示功能

### 9.3 模块跳转服务规范

#### 模块入口规范
1. **入口设计**：
   - ood规范中不存在模块定义入口
   - 主入口是普通的Web服务
   - 在方法服务中声明视图类型使用

2. **MCP注解使用**：
   - 服务入口使用MCP注解
   - @MCPServerAnnotation定义服务基本信息
   - @MCPMethodAnnotation定义方法路径和类型

#### 模块跳转规范
1. **使用@ModuleAnnotation**处理模块间跳转
2. **配置模块视图类型、面板类型和绑定服务类**
3. **支持动态加载(dynLoad)模块**

## 10. 参数规范

### 10.1 参数设计原则

#### 最小化原则
只传递必要的参数，避免传输不必要的数据，提高传输效率和系统性能。

#### 一致性原则
相同类型的业务操作应保持参数设计的一致性，便于开发人员理解和维护。

#### 可读性原则
参数命名应清晰表达其用途，使用具有业务含义的命名方式。

#### 性能原则
简单参数传输效率更高，应根据实际需求选择合适的参数类型。

### 10.2 参数使用场景

#### 简单参数使用场景
1. **重置操作**：通常只需要简单的标识参数
2. **刷新操作**：通常只需要少量筛选参数
3. **根据主键查询**：只需要传递主键参数
4. **状态更新操作**：只需要ID和状态参数

#### 复杂视图对象参数使用场景
1. **表单提交操作**：需要完整的视图数据
2. **复杂查询操作**：需要多个查询条件时使用视图对象
3. **批量操作**：需要处理多个数据项时使用视图对象

### 10.3 参数传递规范

#### 参数命名规范
1. 使用清晰、具有业务含义的命名
2. 保持命名风格一致性（驼峰命名法）
3. 避免使用保留关键字

#### 参数传递规范
1. 参数最小化原则：始终只传递必要的参数
2. 合理使用@RequestBody和简单参数
3. 正确使用@Uid和@Pid注解

#### 安全性考虑
1. 对敏感信息进行适当处理
2. 验证参数的合法性
3. 避免在客户端暴露敏感的参数信息

#### 性能优化
1. 只传递必要的参数
2. 避免传递大对象
3. 合理使用分页参数

## 11. 最佳实践与注意事项

### 10.1 设计经验
- 视图与服务分离，保持职责清晰
- 合理使用枚举增强数据表达能力
- 统一异常处理机制
- 规范化注解使用

### 10.2 实现经验
- 所有通用服务必须具备Web可访问性
- 正确使用Spring MVC注解
- 遵循fastjson序列化规范
- 合理处理遮罩和事件链条

### 10.3 注意事项
- 避免在视图中混合使用不同类型的注解
- 确保列表视图的单一性
- 正确使用@Uid注解标识行主键
- 合理配置模块跳转参数