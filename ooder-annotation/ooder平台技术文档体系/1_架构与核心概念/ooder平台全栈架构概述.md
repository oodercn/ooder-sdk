# ooder平台全栈架构概述

## 目录

1. [平台概述](#1-平台概述)
2. [核心架构理念](#2-核心架构理念)
3. [前端模块化设计](#3-前端模块化设计)
   - 3.1 ood前端框架
   - 3.2 容器组件与展示组件分离
   - 3.3 Page为中心的前端组件组织
4. [后端模块设计](#4-后端模块设计)
   - 4.1 SpringBoot微服务架构
   - 4.2 Web服务模块化
   - 4.3 以Web Path为中心的服务地址统一
5. [通讯模块设计](#5-通讯模块设计)
   - 5.1 前后端通讯组件
   - 5.2 注解驱动的通讯机制
   - 5.3 通讯组件与容器组件的绑定
6. [注解驱动架构](#6-注解驱动架构)
   - 6.1 ooder特定注解体系
   - 6.2 前后端强映射关系
7. [组件化设计](#7-组件化设计)
   - 7.1 组件分类体系
   - 7.2 组件间关系
8. [最佳实践](#8-最佳实践)

## 1. 平台概述

ooder平台是一个基于注解驱动的全栈框架，采用组件化设计思想，实现了前后端的无缝集成。平台通过将前端设计、后端微服务和通讯组件分离，构建了一个灵活、可扩展的应用架构。

ooder平台的核心价值在于通过声明式注解配置，将前端界面、后端服务和通讯机制有机地结合在一起，形成一个完整的、可维护的应用系统。

## 2. 核心架构理念

### 2.1 全栈架构设计

ooder平台采用全栈架构设计，将前端、后端和通讯组件分离，各自独立发展又紧密协作：

1. **前端模块化设计**：采用ood前端框架，实现容器组件与展示组件的分离
2. **后端模块化设计**：基于SpringBoot微服务架构，实现服务模块化
3. **通讯模块独立设计**：横跨前后端，实现组件间的数据交互

### 2.2 组件化设计思想

平台采用组件化设计思想，将复杂功能拆分为可复用的组件模块，通过组合不同组件实现复杂业务场景。

### 2.3 注解驱动架构

通过声明式注解配置实现前后端的强映射关系，将配置与业务逻辑分离，提高代码的可维护性和可读性。

### 2.4 前后端分离

通过注解实现前后端的强类型映射，确保数据传输的一致性和完整性。

## 3. 前端模块化设计

### 3.1 ood前端框架

ooder平台的前端基于ood前端框架构建，该框架提供了丰富的UI组件和灵活的布局能力：

1. **组件丰富性**：提供表单、列表、树形、标签页等多种UI组件
2. **布局灵活性**：支持Panel、Div、Block等多种布局容器
3. **交互友好性**：内置丰富的交互组件和事件处理机制

### 3.2 容器组件与展示组件分离

前端设计采用容器组件（Container Components）和展示组件（Presentational Components）分离的主键策略：

#### 3.2.1 容器组件
容器组件负责业务逻辑处理和数据管理：
- 管理组件状态
- 处理用户交互
- 与通讯组件进行数据交互
- 调用后端服务

#### 3.2.2 展示组件
展示组件负责UI渲染，无状态：
- 专注于界面展示
- 接收数据并渲染
- 不处理业务逻辑
- 可高度复用

### 3.3 Page为中心的前端组件组织

前端以Page为中心动态组织前端组件：

1. **Page作为容器**：Page是前端组件的根容器，组织所有子组件
2. **动态组件加载**：根据业务需求动态加载和卸载组件
3. **组件生命周期管理**：统一管理组件的创建、更新和销毁
4. **上下文环境管理**：通过PageCtx管理页面运行所需的所有上下文信息

## 4. 后端模块设计

### 4.1 SpringBoot微服务架构

后端采用微服务为中心的架构设计，基于SpringBoot框架构建：

1. **服务独立性**：每个微服务独立部署和运行
2. **技术栈统一**：基于Spring生态体系，确保技术栈一致性
3. **可扩展性**：支持水平扩展和垂直扩展
4. **容错性**：通过服务隔离提高系统容错能力

### 4.2 Web服务模块化

后端采用模块化设计，将不同业务功能拆分为独立的Web服务模块：

1. **业务模块化**：按照业务领域划分服务模块
2. **功能模块化**：将通用功能抽象为独立模块
3. **服务复用性**：通过模块化设计提高服务复用率
4. **维护便利性**：模块化设计便于维护和升级

### 4.3 以Web Path为中心的服务地址统一

后端以Web Path(URL)来统一微服务组件地址：

1. **地址统一性**：所有服务通过统一的URL路径进行访问
2. **路由清晰性**：通过URL路径清晰表达服务功能
3. **版本管理**：通过URL路径实现服务版本管理
4. **负载均衡**：支持通过URL路径实现负载均衡

## 5. 通讯模块设计

### 5.1 前后端通讯组件

通讯模块独立设计，横跨前后端，实现组件间的数据交互：

1. **独立性**：通讯组件独立于前端和后端组件
2. **通用性**：提供通用的通讯接口和协议
3. **安全性**：内置安全机制，确保数据传输安全
4. **可靠性**：提供可靠的通讯保障机制

### 5.2 注解驱动的通讯机制

通讯组件通过在后端服务地址上增加组件行为（事件）注解来实现：

1. **注解定义**：通过特定注解定义通讯行为
2. **动态注入**：在Page初始化时动态完成通讯组件的注入
3. **行为扩展**：通过注解扩展通讯组件的行为
4. **配置灵活**：支持通过注解灵活配置通讯参数

### 5.3 通讯组件与容器组件的绑定

通讯组件与容器组件通过注解实现绑定关系：

1. **自动绑定**：Page初始化时自动完成绑定
2. **手动绑定**：支持手动指定绑定关系
3. **动态绑定**：支持运行时动态调整绑定关系
4. **解耦设计**：通过绑定机制实现组件间解耦

## 6. 注解驱动架构

### 6.1 ooder特定注解体系

ooder平台定义了特定的注解体系，用于驱动前后端组件：

#### 6.1.1 视图层注解
- **@CustomAnnotation**：底层通用外观配置
- **@FormViewAnnotation**：表单视图定义
- **@TreeGridViewAnnotation**：网格视图定义
- **@FormAnnotation**：表单配置注解
- **@TreeGridAnnotation**：网格配置注解
- **@PanelAnnotation**：面板容器定义
- **@DialogAnnotation**：对话框容器定义

#### 6.1.2 行为和交互注解
- **@APIEventAnnotation**：核心基础行为配置，定义事件交互行为
- **@ModuleAnnotation**：模块定义注解，用于定义应用模块

#### 6.1.3 字段注解
- **@InputAnnotation**：输入框配置
- **@DatePickerAnnotation**：日期选择器配置
- **@ComboBoxAnnotation**：下拉框配置
- **@ButtonAnnotation**：按钮配置
- **@CustomListAnnotation**：自定义列表配置，用于增强枚举字段的数据能力

#### 6.1.4 菜单注解
- **@ToolBarMenu**：工具栏配置
- **@BottomBarMenu**：底部栏配置
- **CustomFormMenu**：预定义菜单项
- **TreeGridMenu**：网格菜单项

### 6.2 前后端强映射关系

通过注解实现前后端的强类型映射：

1. **组件映射**：ComponentType.INPUT → ood.UI.Input
2. **视图映射**：ViewType.FORM → 表单视图
3. **事件映射**：APIEventAnnotation → 绑定前端事件与后端服务
4. **数据流向**：RequestPathEnum/ResponsePathEnum → 控制前后端数据流向

## 7. 组件化设计

### 7.1 组件分类体系

根据功能和用途，ooder平台的组件分为以下几类：

1. **前端组件**：
   - 容器组件：负责业务逻辑处理和数据管理
   - 展示组件：负责UI渲染，无状态

2. **后端组件**：
   - 微服务组件：基于SpringBoot构建的独立服务
   - 业务组件：处理具体业务逻辑的组件

3. **通讯组件**：
   - APIEvent组件：处理前后端交互事件
   - MQTT组件：处理轻量级消息传输

### 7.2 组件间关系

组件间存在多种关系类型，确保组件能够协同工作：

1. **包含关系**：一个组件包含其他组件作为子组件
2. **依赖关系**：一个组件依赖于其他组件的功能
3. **绑定关系**：通讯组件与容器组件通过注解实现绑定
4. **调用关系**：前端组件调用后端服务组件

## 8. 最佳实践

### 8.1 设计原则

1. **单一职责原则**：每个组件应有明确的职责和用途
2. **可复用性原则**：设计通用组件，提高代码复用率
3. **可维护性原则**：保持代码结构清晰，易于理解和修改
4. **可扩展性原则**：提供扩展机制，支持自定义组件的开发和集成

### 8.2 实现规范

1. **注解使用规范**：正确使用各类注解
2. **服务设计规范**：遵循服务规范，确保Web可访问性
3. **参数设计规范**：遵循参数最小化原则
4. **异常处理规范**：提供完善的异常处理机制

### 8.3 性能优化

1. **组件优化**：合理设计组件结构，避免过度嵌套
2. **通讯优化**：优化通讯协议，减少数据传输量
3. **缓存机制**：合理使用缓存机制提高响应速度
4. **异步处理**：采用异步处理提高系统并发能力

### 8.4 核心理念规范

ooder平台的核心理念规范包括：

1. **视图对象的双重角色**：
   - 数据传输对象(DTO)：视图对象作为数据载体，用于前后端数据传输
   - 视图配置载体：通过注解定义视图的外观、行为和交互

2. **注解与前端框架的强映射关系**：
   - ComponentType.INPUT → ood.UI.Input
   - ViewType.FORM → 表单视图
   - APIEventAnnotation → 绑定前端事件与后端服务
   - RequestPathEnum/ResponsePathEnum → 控制前后端数据流向

3. **注解驱动的设计原则**：
   - 声明式配置：通过注解声明视图结构和行为，而非编程式定义
   - 配置即代码：注解配置与业务逻辑分离，提高可维护性
   - 强类型映射：注解与前端组件一一对应，确保类型安全

### 8.5 组件体系规范

ooder平台的核心组件体系遵循"干-支-叶"结构化设计模式：

#### 干：TabsAnnotation核心注解
TabsAnnotation是Tabs组件体系的核心，定义了Tabs组件的基本行为和属性：

**核心属性：**
- barLocation：控制标签栏的显示位置（BarLocationType.top/none）
- sideBarStatus：控制侧边栏的展开状态（SideBarStatusType.expand/fold）
- iniFold：控制Tabs初始化时是否折叠（true/false）
- bindTypes：可绑定的组件类型（ComponentType.BUTTONVIEWS/TABS/STACKS/FOLDINGTABS）

**核心功能：**
- 传统Tabs模式：显示标签栏，用户可以切换不同标签页
- Card模式：隐藏标签栏，仅显示内容区域，类似于独立的卡片组件
- 多步骤CARD模式：将复杂表单分解为多个独立的CARD页面

#### 支：Tabs组件体系子类
1. **ButtonViews（按钮导航）**
   - ComponentType.BUTTONVIEWS继承自ComponentType.TABS
   - 特有属性noFoldBar控制是否显示折叠按钮
   - 在移动端有专门的MButtonViews变体

2. **FoldingTabs（折叠Tabs）**
   - ComponentType.FOLDINGTABS继承自ComponentType.TABS
   - 支持内容区域的折叠和展开
   - 适用于内容较多的导航场景

3. **Stacks（堆栈容器）**
   - ComponentType.STACKS继承自ComponentType.TABS
   - 以堆栈形式展示内容
   - 支持层叠显示多个内容区域

#### 叶：具体应用场景实现
1. **Card模式应用场景**
   - 独立信息展示：当只需要展示单一内容而不需要标签切换时
   - 聚合视图中的独立卡片：作为聚合视图中的信息块展示

2. **多步骤CARD模式应用场景**
   - 复杂信息录入：员工入职信息录入、项目申报表、客户资料录入等
   - 多阶段业务流程：申请流程、订单处理、调查问卷等
   - 自助建模中的自适应调整：根据字段数量自动分组并提供暂存和提交功能